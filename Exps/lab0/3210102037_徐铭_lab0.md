# Lab 0: RV64 内核调试

## 1 实验目的


按照实验流程搭建实验环境，掌握基本的 Linux 概念与用法，熟悉如何从 Linux 源代码开始将内核运行在 QEMU 模拟器上，学习使用 GDB 跟 QEMU 对代码进行调试，为后续实验打下基础。


## 2 实验内容及要求


- 学习 Linux 基本知识
- 安装 Docker，下载并导入 Docker 镜像，熟悉docker相关指令
- 编译内核并用 GDB + QEMU 调试，在内核初始化过程中设置断点，对内核的启动过程进行跟踪，并尝试使用 GDB 的各项命令



请各位同学独立完成实验，任何抄袭行为都将使本次实验判为0分。

**请跟随实验步骤完成实验并根据本文档中的要求记录实验过程，最后删除文档末尾的附录部分**，将文档导出并命名为**“学号_姓名_lab0.pdf”**，以 pdf 格式上传至学在浙大平台。


## 3 操作方法和实验步骤


### 3.1 安装 Docker 环境并创建容器 (25%)


请参考[【附录B.Docker使用基础】](#4389418c)了解相关背景知识。


#### 3.1.1 安装 Docker 并启动


请参照 [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/) 自行在本机安装 Docker 环境，安装完成后启动 Docker 软件。


#### 3.1.2 下载并导入 Docker 镜像


为了便于开展实验，我们在 [镜像](https://pan.zju.edu.cn/share/b5c2df5dfb1189f2772494d40b) 中提前安装好了实验所需的环境（RISC-V工具链、QEMU模拟器），相关环境变量也以设置完毕。**请下载该 Docker 镜像至本地。**

> 下载好的镜像包不需要解压，后面命令中直接使用。



接下来建议大家使用终端操作，而非使用桌面端等 UI 程序，这样每一步操作有迹可循，易于排查问题。


- Windows 用户：可以使用系统自带的 PowerShell 软件，命令提示符 (cmd) 软件不推荐使用。
- MacOS 用户：使用默认终端即可。
- Linux 用户：使用默认终端即可。



**在执行每一条命令前，请你对将要进行的操作进行思考，给出的命令不需要全部执行，并且不是所有的命令都可以无条件执行，请不要直接复制粘贴命令去执行。**
以下给出的指令中， `$` 提示符表示当前运行的用户为普通用户，`#` 代表 Shell 中注释的标志，他们并非实际输入指令的一部分。


> 导入失败的同学请查看自己的 C 盘空间是否满。



```bash
# 进入 oslab.tar 所在的文件夹
$ cd path/to/oslab # 替换为你下载文件的实际路径

# 导入docker镜像
$ docker import oslab.tar oslab:2023

# 查看docker镜像
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
oslab        2023      9192b7dc0d06   47 seconds ago   2.89GB
```

**请在此处添加你导入容器的执行命令及结果截图：**
答：

![1695643330848](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695643330848.png)


#### 3.1.3 从镜像创建一个容器并进入该容器


请按照以下方法创建新的容器，并建立 volume 映射([参考资料](https://kebingzao.com/2019/02/25/docker-volume/))。建立映射后，你可以方便的在本地编写代码，并在容器内进行编译检查。未来的实验中同样需要用该方法搭建相应的实验环境，但不再作具体指导，请理解每一步的命令并自行更新相关内容。


> 什么是 volumn 映射？其实就是把本地的一个文件夹共享给 Docker 容器用，无论你在容器内修改还是在本地环境下修改，另一边都能感受到这个文件夹变化了。



你也可以参照知识库中提供的，通过配置 VSCode 智能提示来直接连接到 Docker 容器内进行进行实验，**如若此，请提供你使用软件直接在 Docker 容器内进行编辑的截图即可。下文的建立映射关系可以跳过。**


> 如果你使用 VSCode 或其他具有直接连接 Docker 容器功能的软件，你也可以直接在 Docker 容器内进行编辑，而无需建立映射关系，如若此，请提供你使用软件直接在 Docker 容器内进行编辑的截图即可。



> Windows 中的路径一般分 C，D，E 等多盘符，因此 Windows 下的路径一般为 xx盘符:\xx路径，例如 C:\Users\Administor，而 Linux 下与 Windows 不同，Linux 只有一个根目录 /，例如 /home/oslab/lab1 表示 根目录下的 home 文件夹下的 oslab 文件夹 下的 lab1 文件夹，在映射路径时请按照自己系统的路径描述方法填写。更多细节可自行搜索学习。



> Linux 下一般默认 /home 文件夹用来存放用户文件，而别的路径用来存放系统文件，因此请在映射文件夹的时候映射到 /home 的文件夹目录下。/home/aaa 表示 aaa 用户的用户文件所在目录，同理 /home/oslab 表示 oslab 用户的用户文件所在目录。如果你使用的是虚拟机，请映射到 /home/自己用户名 的目录下，一般情况下 ~ 符号等价于 /home/当前用户名，详情请自行搜索 Linux 下 /home 目录含义。



> 一般来说，aaa 用户不能访问 bbb 用户的用户文件，也就是不能访问/修改 /home/bbb 文件夹。但Docker 容器中用的是 root 用户登录，相当于 Windows 中的管理员权限，因此可以访问 /home/oslab 下的文件。



指令仅做参考，注意修改指令中的路径为你自己设置的路径。**如果你使用的是 Windows 系统，建议****不要****将本地新建的目录放在 C 盘等位置。避免后续指令权限问题。本地目录和映射的目录路径不需要相同。**


```shell
# 首先请在本地新建一个目录用作映射需要
$ cd /path/to/your/local/dir
$ mkdir os_experiment

# 创建新的容器，同时建立 volume 映射
$ docker run -it -v /path/to/your/local/dir/os_experiment:/home/oslab/os_experiment oslab:2023 /bin/bash
oslab@3c1da3906541:~$
```

**请在此处添加一张你执行 Docker 映射的命令及结果截图：**
答：<u>这里我是用vscode智能提示直接连接到docker容器内部进行操作的，截图如下</u>

![1695647204356](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695647204356.png)

​	<u>**注意这里，**Container oslab:2023(youthful_bassi)**表示这是在容器内部**</u>

---

后来我在新的容器中试了一下挂载目录：

![1695727275882](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695727275882.png)

**请解释该命令各参数含义：**

- `docker run -it -v /path/to/your/local/dir/os_experiment:/home/oslab/os_experiment oslab:2023 /bin/bash`

答：

-  **docker run ：**创建一个新的容器并启动；
- **-i：**input，以交互模式运行容器，也就是保持标准输入始终打开；
- **-t：**pseudo-terminal，让docker绑定一个伪终端到标准输入上，通常与“-i”同时使用；
- **-v：**volume，本意是卷/目录的意思，这里表示创建一个容器的数据卷，并将宿主机的一个目录挂载到这个卷上；
- **/path/to/your/local/dir/os_experiment：**表示宿主机要挂载的目录；
- **/home/oslab/os_experiment：**容器中的数据卷；
- **oslab:2023：**用于创建容器的镜像；
- **/bin/bash：**用来与容器进行交互的将被绑定到标准输入上的伪终端；


#### 3.1.4 测试映射关系


为测试映射关系是否成功，你可以在本地映射目录中创建任意文件，并在 Docker 容器中进行检查。


```shell
# 在你的本地映射目录中，创建任意文件
$ cd /path/to/your/local/dir/os_experiment
$ touch testfile
$ ls
testfile
```


以上指令将在你的本地映射目录创建一个文件，接下来在容器中执行指令进行检查。


```shell
# 在 Docker 容器中确认是否挂载成功
root@dac72a2cc625:/home/oslab/os_experiment$ ls
testfile
# 退出docker，退出后容器将变为关闭状态，再次进入时需要重新启动容器（不是重新创建容器）
root@dac72a2cc625:/home/oslab/os_experiment$ exit
```


可以看到创建的文件存在，证明映射关系建立成功，接下来你可以使用你喜欢的 IDE 在该目录下进行后续实验的编码了。

**请在此处添加你测试映射关系的全指令截图：**
答：由于我使用的是VScode连接，因此这里在VScode中创建新文件，检查Docker容器中是否有相应改动：

在VScode中创建新txt文件`os_lab0_test`，并输入内容`os lab0 test`

![1695725127416](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695725127416.png)

在bash中检查容器，发现有该文件存在，且内容一致，说明VScode智能提示设置成功；

![1695725250579](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695725250579.png)

---

在新容器中的目录挂载测试结果：

![1695727486163](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695727486163.png)

![1695727518101](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695727518101.png)

其他常用docker指令如下，在后续的实验过程中将会经常使用这些命令：


```shell
# 查看当前运行的容器
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

# 查看所有存在的容器
$ docker ps -a
CONTAINER ID   IMAGE        COMMAND       CREATED              STATUS                          PORTS     NAMES
95efacf34d2c   oslab:2023   "/bin/bash"   About a minute ago   Exited (0) About a minute ago             oslab

# 启动处于停止状态的容器
$ docker start oslab
$ docker ps
CONTAINER ID   IMAGE        COMMAND       CREATED         STATUS          PORTS     NAMES
95efacf34d2c   oslab:2023   "/bin/bash"   2 minutes ago   Up 26 seconds             oslab

# 进入已经运行的容器
$ docker attach oslab
root@95efacf34d2c:/#

# 在已经运行的docker中运行/bin/bash命令，开启一个新的进程
$ docker exec -it oslab /bin/bash
root@95efacf34d2c:/#
```


### 3.2 编译 Linux 内核 (25%)


请参考[【附录E.LINUX 内核编译基础】](#1ee65285)了解相关背景知识。


```bash
# 以下指令均在容器中操作

# 进入实验目录
$ cd /home/oslab/lab0

# 查看当前目录文件
$ ls
linux  rootfs.ext4

# 创建目录，用来存储编译结果
$ mkdir -p build/linux

# 编译 Linux 内核
$ make -C linux \
       O=/home/oslab/lab0/build/linux \
       CROSS_COMPILE=riscv64-unknown-linux-gnu- \
       ARCH=riscv \
       CONFIG_DEBUG_INFO=y \
       defconfig \
       all \
       -j$(nproc)
```


有关 make 指令和 makefile 的知识将在 Lab1 进一步学习。这里简单介绍一下编译 Linux 内核各参数的含义。



| `-C linux` | 表示进入 linux 文件夹，并执行该目录下的 makefile 文件。因此，你执行该命令时应在 `/home/oslab/lab0` 路径下。 |
| --- | --- |
| `O=.....` | 指定变量 O 的值，O 变量在 linux makefile 里用来表示编译结果输出的路径 |
| `CROSS_COMPILE=.....` | 指定变量 CROSS_COMPILE 的值，linux makefile 中使用CROSS_COMPILE 变量的值作为前缀选择编译时使用的工具链。例如本例子中， `riscv64-unknown-linux-gnu-gcc`即是实际编译时调用的编译器。 |
| `ARCH=.....` | 指定编译的目标平台 |
| `CONFIG_DEBUG_INFO=y` | 同上，当该变量设置时，编译过程中将加入 `-g` 配置，这会使得编译结果是包含调试信息的，只有这样我们才可以比较好的进行调试。 |
| `defconfig` | 指定本次编译的目标，支持什么编译目标是 linux makefile 中已经定义好的，defconfig 就表示本次编译要编译出 defconfig 这个目标，该目标代表编译需要的一些配置文件。 |
| `all` | 指定本次编译的目标，目标是可以有多个的。这里的 all 并不表示编译所有目标，而是 makefile 中定义好的一个名称为 all 的编译目标。该目标代表 linux 内核。 |
| `-j$(nproc)`  | `-j` 表示采用多线程编译，后跟数字表示采用线程数量。例如 `-j4` 表示 4 线程编译。这里的 `${nproc}` 是 shell 的一种语法，表示执行 `nproc` 命令，并将执行的结果替换这段字符串。 `nproc` 命令会返回本机器的核心数量。 |

> 编译报错为 Error.137 的同学，可能是电脑性能不足，可以将最后的参数改为 -j1，降低资源消耗。




> 在docker的设置中可以调整给docker分配的资源数量，可以根据需要适当调整。
> ![image.png](https://yuque.zju.edu.cn/images/yuque/0/2023/png/32491/1694596860063-263787ec-af74-4edd-8dbd-bf14ca01b204.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1100&originWidth=2488&size=155456&status=done&style=none&width=1244)
> 如果还不行的话，可以给电脑分配更多的虚拟内存解决，Linux 上可以创建 swap 分区，Windows 上可以在我的电脑，高级设置中修改虚拟内存大小。



**请在此处添加一张你的编译完成的结果截图：**
答：编译过程的截图很长，这里就放一张最后编译完成的截图：

![1695652077240](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695652077240.png)


### 3.3 使用 QEMU 运行内核 (25%)


请参考[【附录C.QEMU使用基础】](#bd00d2f4)了解相关背景知识。


**注意，QEMU的退出方式较为特殊，需要先按住 `ctrl+a`，放开后再按一次 `x`。**


```bash
$ cd /home/oslab/lab0

# 如果不在上面目录下执行的话，请手动修改 -kernel 和 file=.... 的文件路径，这里使用的是相对路径
$ qemu-system-riscv64 \
		-nographic \
    -machine virt \
    -kernel build/linux/arch/riscv/boot/Image  \
 		-device virtio-blk-device,drive=hd0 \
    -append "root=/dev/vda ro console=ttyS0"   \
 		-bios default -drive file=rootfs.ext4,format=raw,id=hd0 \
 		-netdev user,id=net0 -device virtio-net-device,netdev=net0
 
# 执行成功会提示登录，默认用户名为 root，密码为空，这里输入 root 进入即可
# Welcome to Buildroot
# buildroot login:
```


登录成功后，你可以在这个模拟运行的内核系统里到处看看。使用 `uname -a` 指令来确定你运行的系统是 riscv64 架构。

**请在此处添加一张你成功登录后的截图：**
答：

![1695715860447](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695715860447.png)

**请在此处添加一张你运行 ** **`uname -a` ** 指令后的结果截图：
答：

![1695715913281](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695715913281.png)

### 3.4 使用 GDB 调试内核 (25%)


请参考[【附录D.GDB使用基础】]()了解相关背景知识。学会调试将在后续实验中为你提供帮助，推荐同学们跟随[GDB调试入门指南](https://zhuanlan.zhihu.com/p/74897601) 教程完成相应基础练习，熟悉 GDB 调试的使用。


首先请你退出上一步使用 QEMU 运行的内核，并重新使用 QEMU 按照下述参数模拟运行内核（**不是指在上一步运行好的 QEMU 运行的内核中再次运行下述命令！**）。


```shell
$ qemu-system-riscv64 \
		-nographic \
    -machine virt \
    -kernel build/linux/arch/riscv/boot/Image  \
 		-device virtio-blk-device,drive=hd0 \
    -append "root=/dev/vda ro console=ttyS0"   \
 		-bios default -drive file=rootfs.ext4,format=raw,id=hd0 \
 		-netdev user,id=net0 -device virtio-net-device,netdev=net0 \
    -S \
    -s
 
 # -S: 表示启动时暂停执行，这样我们可以在 GDB 连接后再开始执行
 # -s: -gdb tcp::1234 的缩写，会开启一个 tcp 服务，端口为 1234，可以使用 GDB 连接并进行调试
```


上述命令由于 `-S` 的原因，执行后会直接停止，表现为没有任何反应。**接下来再打开一个终端，进入同一个 Docker 容器**，并切换到 `lab0` 目录，使用 GDB 进行调试。


```shell
# 进入同一个 Docker 容器
$ docker exec -it oslab /bin/bash

# 切换到 lab0 目录
$ cd /home/oslab/lab0/

# 使用 GDB 进行调试
$ riscv64-unknown-linux-gnu-gdb build/linux/vmlinux
```


**顺序执行下列 GDB 命令，写出每条命令的含义并附上执行结果的截图。(可以全部执行后一起截图，不需要每个命令截一次图)**


```shell
(gdb) target remote localhost:1234
```


- 含义：target remote 命令表示远程调试，而 1234 是上述 QEMU 执行时指定的用于调试连接的端口号。
- 执行结果：

![1695717211370](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695717211370.png)

```shell
(gdb) b start_kernel 
(gdb) b *0x80000000
(gdb) b *0x80200000
(gdb) info breakpoints
(gdb) delete 2
(gdb) info breakpoints
```


- 含义：


  - b start_kernel：b是breakpoint的简写，这里是设置断点的意思，通过查看main.c源文件可知，这里是将断点设置在函数start_kernel处；

    ![1695719455656](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695719455656.png)

  - b *0x80000000：在运行程序后地址为0x80000000处设置断点；

  - b *0x80200000：在运行程序后地址为0x80200000处设置断点；

  - info breakpoints：查看当前的已设置的所有断点信息，每个断点按设置先后顺序有一个标号；

  - delete 2：删除标号为2的断点；

- 执行结果：

![1695721700559](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695721700559.png)

```shell
(gdb) continue
(gdb) delete 3
(gdb) continue
(gdb) step
(gdb) s
(gdb) (不做输入，直接回车)
(gdb) next
(gdb) n
(gdb) (不做输入，直接回车)
```


- 含义：

  - continue：程序继续执行直到下一个断点
  - step：执行下一条指令，且如果是函数调用，进入函数内部；简写为s；
  - next：执行下一条指令，不进入函数内部；简写为n；
  - (不做输入，直接回车)：默认执行GDB上一条执行的命令；
- 执行结果：

![1695722953685](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695722953685.png)

```shell
(gdb) disassemble
(gdb) nexti
(gdb) n
(gdb) stepi
(gdb) s
```


- 含义：


  - disassemble： 反汇编一段代码，不带参数，默认的反汇编范围是所选择帧的pc附近的函数 
  - nexti：汇编层面上的执行下一条机器码指令，不进入函数；
  - stepi：汇编层面上的执行下一条机器码指令，且如果遇到子函数会进入函数内部；

- 执行结果：

  ![1695724059391](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695724059391.png)

  ![1695724190507](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695724190507.png)

  ![1695724145599](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695724145599.png)

- **请回答：nexti 和 next 的区别在哪里？stepi 和 step 的区别在哪里？next 和 step 的区别是什么？**
  答：

  ​	`nexti/stepi`均表示汇编级别的断点定位，执行下一条汇编指令，其中`nexti`不进入函数内部直接跳过，`stepi`进入函数内部；

  ​	`next/step`均表示C语言级别的断点定位，执行下一条C语言指令，其中`next`不进入函数内部，`step`进入函数内部；

```shell
(gdb) continue
# 这个地方会卡住，可以用 ctrl+c 强行中断
(gdb) quit
```


- 含义：

  - quit：退出GDB调试
- 执行结果：

![1695724701698](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1695724701698.png)

**`vmlinux`**和**`Image`**的关系和区别是什么？为什么 QEMU 运行时使用的是 **`Image`**而不是**`vmlinux`**？
**提示：一个可执行文件包括哪几部分？从vmlinux到Image发生了什么？**
答：

- 关系和区别

关系：

​	vmlinux和Image都与Linux内核有关，都是用户对Linux内核代码进行编译后生成的；一般来说，它们都包含内核的二进制代码，而且它们都还没有被压缩；

区别：

​	vmlinux实质上是ELF文件，它不仅包含完整的二进制内核代码，而且包含这些可执行文件的一些调试信息和符号表等；

​	Image只含有内核的二进制代码，不包含符号信息和调试信息；

因此， vmlinux常用于开发和调试，而Image用于引导和运行Linux系统；

- QEMU使用Image而不是vmlinux

1. QEMU通常在虚拟化环境中用于运行虚拟机，而不是直接在物理硬件上引导操作系统。因此，它需要一个包含已编译内核的二进制映像，而不是包含完整内核源代码和调试信息的vmlinux；

2. vmlinux文件通常非常大，因为它包含了完整的内核源代码和调试信息。启动一个虚拟机时，加载这个巨大的文件会花费很多时间，而Image文件通常只包含已编译的内核二进制代码，因此启动速度更快；

3. 虚拟机通常运行在受限资源的环境中，例如云服务器或嵌入式设备。使用Image文件可以节省磁盘空间和内存，因为它更小；

4. 在生产环境中，通常不希望将内核的完整源代码和调试信息暴露给运行在虚拟机中的应用程序或用户。使用Image文件可以减少潜在的安全风险；


## 4 讨论和心得

​	实验过程中遇到的问题大部分集中在安装docker环境并创建容器那里，由于docker对计算机硬件的一些要求，我在安装docker时选择了只需要Linux环境的docker engine，然而，缺乏图形化界面、缺乏硬件支持的问题难以解决；

​	经过多方查阅资料后我才发现，docker desktop in Windows只需要电脑上安装好WSL2作为后端，并做好相应的配置即可正常使用，并不需要关心所谓的Hyper-V、KVM等硬件的虚拟化的支持，因此最后也就顺利解决了问题；

​	总体使用上而言，除了docker鲸吞了我大量C盘空间外，使用体验还行，命令的风格类似Linux，后面作好容器目录的挂载后实现了文件夹的文件同步，十分畅快。